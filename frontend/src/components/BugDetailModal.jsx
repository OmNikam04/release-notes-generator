import { useState, useEffect } from 'react';
import { useSelector } from 'react-redux';
import './BugDetailModal.css';
import { releaseNotesAPI } from '../services/api';
import Toast from './Toast';

const BugDetailModal = ({ bug, onClose, onApprovalChange }) => {
  if (!bug) return null;

  // Get current user from Redux
  const user = useSelector((state) => state.auth.user);

  // Handle both old format (bug.bugsby_id) and new format (bug.bug.bugsby_id)
  const bugData = bug.bug || bug;

  const [releaseNote, setReleaseNote] = useState(bug.content || '');
  const [alternatives, setAlternatives] = useState([]);
  const [aiConfidence, setAiConfidence] = useState(bug.ai_confidence || null);
  const [aiReasoning, setAiReasoning] = useState(bug.ai_reasoning || null);
  const [aiModel, setAiModel] = useState(bug.ai_model || null);
  const [generatedBy, setGeneratedBy] = useState(bug.generated_by || null);
  const [currentStatus, setCurrentStatus] = useState(bug.status || 'ai_generated');

  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [approvalLoading, setApprovalLoading] = useState(false);
  const [approvalError, setApprovalError] = useState('');
  const [feedback, setFeedback] = useState('');

  // NEW: State for manager's edited content
  const [editedContent, setEditedContent] = useState(bug.content || '');

  // Toast state
  const [toast, setToast] = useState({ show: false, message: '', type: 'info' });

  // Fetch full bug details and release note metadata on mount
  useEffect(() => {
    const fetchBugDetails = async () => {
      // The bug prop is a release note object with bug_id field
      // We need to use bug.bug_id to fetch the release note
      const bugIdToFetch = bug.bug_id || bugData.id;
      if (!bugIdToFetch) {
        console.log('[BugDetailModal] No bug ID available to fetch');
        return;
      }

      setLoading(true);
      setError('');

      try {
        console.log('[BugDetailModal] Fetching release note details for bug:', bugIdToFetch);

        // Fetch release note data which includes AI metadata and alternatives
        const releaseNoteResponse = await releaseNotesAPI.getReleaseNoteByBugId(bugIdToFetch);
        console.log('[BugDetailModal] Release note details:', releaseNoteResponse);

        // Update with release note information if available
        // Note: getReleaseNoteByBugId returns response.data directly, not wrapped
        if (releaseNoteResponse) {
          const releaseNoteData = releaseNoteResponse;
          console.log('[BugDetailModal] Extracted release note data:', releaseNoteData);
          console.log('[BugDetailModal] ai_alternative_versions value:', releaseNoteData.ai_alternative_versions);
          console.log('[BugDetailModal] ai_alternative_versions type:', typeof releaseNoteData.ai_alternative_versions);

          // Update AI metadata
          if (releaseNoteData.ai_confidence) {
            console.log('[BugDetailModal] AI Confidence:', releaseNoteData.ai_confidence);
            setAiConfidence(releaseNoteData.ai_confidence);
          }
          if (releaseNoteData.ai_reasoning) {
            console.log('[BugDetailModal] AI Reasoning:', releaseNoteData.ai_reasoning);
            setAiReasoning(releaseNoteData.ai_reasoning);
          }
          if (releaseNoteData.ai_model) {
            console.log('[BugDetailModal] AI Model:', releaseNoteData.ai_model);
            setAiModel(releaseNoteData.ai_model);
          }
          if (releaseNoteData.generated_by) {
            console.log('[BugDetailModal] Generated By:', releaseNoteData.generated_by);
            setGeneratedBy(releaseNoteData.generated_by);
          }

          // Parse and display alternative versions
          if (releaseNoteData.ai_alternative_versions) {
            try {
              console.log('[BugDetailModal] Raw alternatives:', releaseNoteData.ai_alternative_versions);
              const alts = JSON.parse(releaseNoteData.ai_alternative_versions);
              const altArray = Array.isArray(alts) ? alts : [];
              console.log('[BugDetailModal] Parsed alternatives:', altArray);
              setAlternatives(altArray);
            } catch (e) {
              console.error('[BugDetailModal] Could not parse alternatives:', e);
              console.log('[BugDetailModal] Raw alternatives string:', releaseNoteData.ai_alternative_versions);
              setAlternatives([]);
            }
          } else {
            console.log('[BugDetailModal] No alternatives available');
            setAlternatives([]);
          }

          // NEW: Initialize editedContent with the current release note content
          if (releaseNoteData.content) {
            setEditedContent(releaseNoteData.content);
          }
        }
      } catch (err) {
        console.error('[BugDetailModal] Failed to fetch release note details:', err);
        console.log('[BugDetailModal] Error details:', err.message);
        setError('Failed to load release note details');
      } finally {
        setLoading(false);
      }
    };

    fetchBugDetails();
  }, [bug.bug_id, bugData.id]);

  const handleUseAlternative = (alternative) => {
    setReleaseNote(alternative);
    setEditedContent(alternative); // Also update the editable version
  };

  // Developer: Send to approval (change status to dev_approved)
  const handleSendToApproval = async () => {
    if (!releaseNote.trim()) {
      setApprovalError('Release note cannot be empty');
      return;
    }

    setApprovalLoading(true);
    setApprovalError('');

    try {
      console.log('[BugDetailModal] Sending to approval:', bug.id);
      await releaseNotesAPI.updateReleaseNote(bug.id, releaseNote, 'dev_approved');
      setCurrentStatus('dev_approved');
      console.log('[BugDetailModal] Successfully sent to approval');

      // Show success message
      setApprovalError('‚úÖ Successfully sent to approval! Refreshing board...');

      // Wait a moment for user to see the success message
      setTimeout(() => {
        // Notify parent component to refresh Kanban board
        if (onApprovalChange) {
          console.log('[BugDetailModal] Calling onApprovalChange to refresh board');
          onApprovalChange({ status: 'dev_approved', releaseNoteId: bug.id });
        }
      }, 1500);
    } catch (err) {
      console.error('[BugDetailModal] Failed to send to approval:', err);
      setApprovalError(err.message || 'Failed to send to approval');
    } finally {
      setApprovalLoading(false);
    }
  };

  // Manager: Submit feedback only (without approval)
  const handleSubmitFeedback = async () => {
    if (!feedback.trim() && editedContent === releaseNote) {
      setApprovalError('Please provide feedback or make edits before submitting');
      return;
    }

    setApprovalLoading(true);
    setApprovalError('');

    try {
      console.log('[BugDetailModal] Submitting feedback/edits without approval');

      // Check if manager made edits
      const hasEdits = editedContent !== releaseNote;

      if (hasEdits) {
        console.log('[BugDetailModal] Manager made edits - updating release note content');
        // Update the release note content without changing status
        await releaseNotesAPI.updateReleaseNote(bug.id, editedContent, currentStatus);

        // Update local state to reflect the change
        setReleaseNote(editedContent);
      }

      // TODO: Add a separate endpoint to save feedback without approval
      // For now, we'll just show a success message
      // In the future, this should call a dedicated feedback endpoint

      console.log('[BugDetailModal] Feedback/edits saved successfully');

      // Show success message
      setApprovalError('');
      setFeedback(''); // Clear feedback after submission

      // Show success toast notification
      setToast({
        show: true,
        message: hasEdits
          ? 'Changes saved successfully! Feedback will be captured when you approve.'
          : 'Feedback noted! It will be captured when you approve the release note.',
        type: 'success'
      });

      // Refresh the bug details (status remains the same)
      if (onApprovalChange) {
        onApprovalChange({ status: currentStatus, releaseNoteId: bug.id });
      }
    } catch (err) {
      console.error('[BugDetailModal] Failed to submit feedback:', err);
      setApprovalError(err.message || 'Failed to submit feedback');
    } finally {
      setApprovalLoading(false);
    }
  };

  // Manager: Approve release note
  const handleApprove = async () => {
    setApprovalLoading(true);
    setApprovalError('');

    try {
      console.log('[BugDetailModal] Approving release note:', bug.id);

      // Check if manager made edits to the release note
      const hasEdits = editedContent !== releaseNote;
      const correctedContent = hasEdits ? editedContent : null;

      if (hasEdits) {
        console.log('[BugDetailModal] Manager made edits - AI will learn from corrections');
        console.log('[BugDetailModal] Original:', releaseNote.substring(0, 100) + '...');
        console.log('[BugDetailModal] Corrected:', editedContent.substring(0, 100) + '...');
      }

      if (feedback.trim()) {
        console.log('[BugDetailModal] Manager provided feedback:', feedback);
      }

      // Send approval with corrected content and feedback
      await releaseNotesAPI.approveReleaseNote(bug.id, 'approve', correctedContent, feedback);
      setCurrentStatus('mgr_approved');
      console.log('[BugDetailModal] Successfully approved');

      // Show success message
      if (hasEdits || feedback.trim()) {
        setApprovalError('‚úÖ Successfully approved! AI is learning from your feedback... Refreshing board...');
      } else {
        setApprovalError('‚úÖ Successfully approved! Refreshing board...');
      }

      // Wait a moment for user to see the success message
      setTimeout(() => {
        // Notify parent component to refresh Kanban board
        if (onApprovalChange) {
          console.log('[BugDetailModal] Calling onApprovalChange to refresh board');
          onApprovalChange({ status: 'mgr_approved', releaseNoteId: bug.id });
        }
      }, 1500);
    } catch (err) {
      console.error('[BugDetailModal] Failed to approve:', err);
      setApprovalError(err.message || 'Failed to approve');
    } finally {
      setApprovalLoading(false);
    }
  };



  const getStatusColor = (status) => {
    const colors = {
      'pending': '#f39c12',
      'ai_generated': '#f39c12',
      'dev_approved': '#3498db',
      'mgr_approved': '#9b59b6',
      'approved': '#27ae60',
      'rejected': '#e74c3c'
    };
    return colors[status] || '#95a5a6';
  };

  const getStatusLabel = (status) => {
    const labels = {
      'pending': 'Pending',
      'ai_generated': 'AI Generated',
      'dev_approved': 'Dev Approved',
      'mgr_approved': 'Mgr Approved',
      'approved': 'Approved',
      'rejected': 'Rejected'
    };
    return labels[status] || status;
  };

  // Determine which approval buttons to show based on status and user role
  const isDeveloper = user?.role === 'developer';
  const isManager = user?.role === 'manager';
  const isAiGenerated = currentStatus === 'ai_generated';
  const isDevApproved = currentStatus === 'dev_approved';
  const isMgrApproved = currentStatus === 'mgr_approved';
  const isRejected = currentStatus === 'rejected';

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        <div className="modal-header">
          <div className="modal-title-section">
            <h2 className="modal-title">{bugData.title}</h2>
            <div className="modal-badges">
              <span className="status-label-text">Status:</span>
              <span
                className="modal-badge status-badge"
                style={{ backgroundColor: getStatusColor(bug.status) }}
              >
                {getStatusLabel(bug.status)}
              </span>
            </div>
          </div>
          <button className="modal-close-btn" onClick={onClose}>
            ‚úï
          </button>
        </div>

        <div className="modal-body">
          <div className="modal-main-content">
          {/* Bug Details - FIRST */}
          <div className="modal-details-section">
            <div className="modal-section">
              <h3 className="section-title">
                <span className="title-icon">üêõ</span>
                Bug Details
              </h3>

              <div className="detail-description">
                <span className="detail-label">Description</span>
                <div className="detail-value description-scroll">
                  {bugData.description || 'No description available'}
                </div>
              </div>

              <div className="details-grid">
                <div className="detail-item">
                  <span className="detail-label">Bug ID</span>
                  <span className="detail-value">{bugData.bugsby_id}</span>
                </div>
                <div className="detail-item">
                  <span className="detail-label">Severity</span>
                  <span className="detail-value severity-badge">
                    {bugData.severity || 'N/A'}
                  </span>
                </div>
                <div className="detail-item">
                  <span className="detail-label">Priority</span>
                  <span className="detail-value">{bugData.priority || 'N/A'}</span>
                </div>
                <div className="detail-item">
                  <span className="detail-label">Component</span>
                  <span className="detail-value">{bugData.component || 'N/A'}</span>
                </div>
                <div className="detail-item">
                  <span className="detail-label">Bug Type</span>
                  <span className="detail-value">{bugData.bug_type || 'N/A'}</span>
                </div>
                <div className="detail-item">
                  <span className="detail-label">Release</span>
                  <span className="detail-value">{bugData.release || 'N/A'}</span>
                </div>
                <div className="detail-item">
                  <span className="detail-label">Assigned To</span>
                  <span className="detail-value">{bugData.assigned_to || 'Unassigned'}</span>
                </div>
                {bugData.cve_number && (
                  <div className="detail-item">
                    <span className="detail-label">CVE Number</span>
                    <span className="detail-value cve-badge">{bugData.cve_number}</span>
                  </div>
                )}
                <div className="detail-item">
                  <span className="detail-label">Created At</span>
                  <span className="detail-value">{bugData.created_at ? new Date(bugData.created_at).toLocaleString() : 'N/A'}</span>
                </div>
                <div className="detail-item">
                  <span className="detail-label">Last Synced</span>
                  <span className="detail-value">{bugData.last_synced_at ? new Date(bugData.last_synced_at).toLocaleString() : 'Never'}</span>
                </div>
              </div>
            </div>
          </div>

          {/* Generated Release Note - SECOND */}
          <div className="modal-response-section">
            <div className="modal-section">
              <h3 className="section-title">
                <span className="title-icon">‚ú®</span>
                AI Generated Release Note
              </h3>
              <div className="ai-generated-content">
                {releaseNote || 'The AI-generated release note will appear here...'}
              </div>

              {/* Alternative Suggestions */}
              <div className="alternative-suggestions">
                <h4 className="suggestions-title">üí° Alternative Versions</h4>
                <div className="suggestions-list">
                  {alternatives.map((alt, index) => (
                    <div key={index} className="suggestion-item">
                      <div className="suggestion-content">{alt}</div>
                      <button
                        className="btn-use-suggestion"
                        onClick={() => handleUseAlternative(alt)}
                      >
                        Use This
                      </button>
                    </div>
                  ))}
                </div>
              </div>

              {/* SEQUENCE 1: Edit Release Note Section for Manager */}
              {isManager && isDevApproved && (
                <div className="manager-edit-section-left">
                  <h4 className="edit-title">üìù Edit Release Note (Optional)</h4>
                  <p className="edit-hint-text">
                    Make corrections to improve AI learning
                  </p>
                  <textarea
                    className="manager-edit-input-left"
                    placeholder="Edit the release note if needed..."
                    value={editedContent}
                    onChange={(e) => setEditedContent(e.target.value)}
                    rows="6"
                  />
                  {editedContent !== releaseNote && (
                    <div className="edit-indicator">
                      ‚úèÔ∏è You've made changes - AI will learn from your corrections
                    </div>
                  )}
                </div>
              )}

              {/* SEQUENCE 2: Feedback Section - AFTER edit section */}
              {isManager && isDevApproved && (
                <div className="feedback-section">
                  <h4 className="feedback-title">üí¨ Feedback Comments (Optional)</h4>
                  <p className="feedback-hint">
                    Explain why you made changes. This feedback will be used to improve future AI generations.
                  </p>
                  <textarea
                    className="feedback-input"
                    placeholder="E.g., 'Too technical', 'Missing CVE details', 'Simplified language'..."
                    value={feedback}
                    onChange={(e) => setFeedback(e.target.value)}
                    rows="3"
                  />
                  <button
                    className="btn-submit-feedback"
                    onClick={handleSubmitFeedback}
                    disabled={(!feedback.trim() && editedContent === releaseNote) || approvalLoading}
                  >
                    üíæ Save Changes
                  </button>
                  <p className="feedback-save-hint">
                    Note: This saves your edits without approving. Feedback will be captured when you approve.
                  </p>
                </div>
              )}
            </div>
          </div>
          </div>

          {/* Approval Workflow - RIGHT SIDE */}
          <div className="modal-approval-section">
            <div className="approval-card">
              <h3 className="approval-title">üìã Release Note Status</h3>

              {/* Current Status */}
              <div className="approval-status">
                <span className="status-label">Current Status</span>
                <span
                  className="status-value"
                >
                  {getStatusLabel(currentStatus)}
                </span>
              </div>

              {/* AI Metadata */}
              <div className="approval-info">
                <p className="info-text">
                  <strong>Generated By:</strong> {generatedBy || 'N/A'}
                </p>
                {aiConfidence && (
                  <p className="info-text">
                    <strong>AI Confidence:</strong> {(aiConfidence * 100).toFixed(0)}%
                  </p>
                )}
                {aiModel && (
                  <p className="info-text">
                    <strong>AI Model:</strong> {aiModel}
                  </p>
                )}
                {aiReasoning && (
                  <p className="info-text reasoning-text">
                    <strong>AI Reasoning:</strong> {aiReasoning}
                  </p>
                )}
              </div>

              {/* Error Message */}
              {approvalError && (
                <div className="approval-error">
                  ‚ö†Ô∏è {approvalError}
                </div>
              )}

              {/* Developer Approval Actions - Show when status is ai_generated */}
              {isDeveloper && isAiGenerated && (
                <div className="approval-actions">
                  <button
                    className="btn-approval-primary"
                    onClick={handleSendToApproval}
                    disabled={approvalLoading}
                  >
                    {approvalLoading ? '‚è≥ Sending...' : '‚úì Send to Approval'}
                  </button>
                </div>
              )}

              {/* Manager Approval Actions - Show when status is dev_approved */}
              {isManager && isDevApproved && (
                <div className="approval-actions manager-actions">
                  {/* Single Approve Button */}
                  <div className="manager-buttons">
                    <button
                      className="btn-approval-approve"
                      onClick={handleApprove}
                      disabled={approvalLoading}
                    >
                      {approvalLoading ? '‚è≥ Approving...' : '‚úÖ Approve Release Note'}
                    </button>
                  </div>

                  {/* Learning Indicator - Shows when manager made edits or added feedback */}
                  {(editedContent !== releaseNote || feedback.trim()) && (
                    <div className="learning-indicator">
                      <span className="learning-icon">üß†</span>
                      <span className="learning-text">
                        AI will learn from your {editedContent !== releaseNote ? 'corrections' : 'feedback'}
                      </span>
                    </div>
                  )}
                </div>
              )}

              {/* Status: Already Approved */}
              {isMgrApproved && (
                <div className="approval-status-final">
                  <p className="final-status-text">‚úÖ This release note has been approved and is ready for release.</p>
                </div>
              )}

              {/* Status: Rejected */}
              {isRejected && (
                <div className="approval-status-rejected">
                  <p className="rejected-status-text">‚ùå This release note was rejected. Please review and resubmit.</p>
                </div>
              )}

              {/* Status: Dev Approved (waiting for manager) */}
              {isDevApproved && !isManager && (
                <div className="approval-status-pending">
                  <p className="pending-status-text">‚è≥ Waiting for manager approval...</p>
                </div>
              )}
            </div>
          </div>
        </div>

        <div className="modal-footer">
          <button className="btn-modal-secondary" onClick={onClose}>
            Close
          </button>
        </div>
      </div>

      {/* Toast Notification */}
      <Toast
        show={toast.show}
        message={toast.message}
        type={toast.type}
        onClose={() => setToast({ ...toast, show: false })}
        duration={5000}
        position="bottom-right"
      />
    </div>
  );
};

export default BugDetailModal;
